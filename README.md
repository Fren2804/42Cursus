# üîßüß± In Progress üß±üîß
# üè¢Cursus 42 - Campus 42 Madrid üá™üá∏

Bienvenido a mi repositorio del **Cursus 42**, donde ir√© subiendo todos mis proyectos completados y corregidos. Aqu√≠ encontrar√°s implementaciones en C, estructuras de datos, algoritmos y otros ejercicios desarrollados en el marco del programa de formaci√≥n de **42 Madrid**. Dentro de cada repositorio habr√° mas informaci√≥n en detalle de cada proyecto.

---
## √çndice

1. [Libft](https://github.com/Fren2804/Libft)üè†  
   1.1 [Explicaci√≥n](#explicaci√≥n-libft)
2. [Get_Next_Line](https://github.com/Fren2804/Get_Next_Line)üè†  
   2.1 [Explicaci√≥n](#explicaci√≥n-get_next_line)
3. [Ft_Printf](https://github.com/Fren2804/Ft_Printf)üè†  
   3.1 [Explicaci√≥n](#explicaci√≥n-ft_printf)
4. Born2berootüè†  
   4.1 [Explicaci√≥n](#explicaci√≥n-born2beroot)
5. [Fdf](https://github.com/Fren2804/FDF)üè†  
   5.1 [Explicaci√≥n](#explicaci√≥n-fdf)
6. [Pipex](https://github.com/Fren2804/Pipex)üè†  
   6.1 [Explicaci√≥n](#explicaci√≥n-pipex)
7. [Push_Swap](https://github.com/Fren2804/Push_Swap)üè†  
   7.1 [Explicaci√≥n](#explicaci√≥n-push_swap)
8. Exam02üè†  
   8.1 [Explicaci√≥n](#explicaci√≥n-exam02)



# Explicaci√≥n

## Explicaci√≥n Libft

Este es el primer proyecto del campus 42, en el que se nos introducen ciertas pautas fundamentales y se nos pide replicar muchas de las funciones b√°sicas de la biblioteca est√°ndar de C. El objetivo principal es que comprendamos en profundidad c√≥mo funcionan estas funciones, su prop√≥sito y c√≥mo implementarlas correctamente, ya que formar√°n la base para los pr√≥ximos proyectos.

Durante este proyecto, aprendemos a crear un Makefile que automatiza la compilaci√≥n y generaci√≥n de la biblioteca. Tambi√©n nos enfocamos en vincular todos los archivos .c mediante un archivo de cabecera .h, lo que nos permite generar una biblioteca completamente funcional.

La experiencia adquirida en este proyecto nos ayuda a dominar el manejo de memoria din√°mica, las cadenas de caracteres y otras operaciones fundamentales en C, sentando las bases para convertirnos en desarrolladores m√°s s√≥lidos y organizados.

## Resultado Libft

![Libft Results](https://github.com/user-attachments/assets/11105315-a2a0-4cc2-8c29-3cc0c523f2e4)

## Repositorio Libft

https://github.com/Fren2804/Libft

## Explicaci√≥n Get_Next_Line

Este fue mi segundo proyecto, en el que se nos pide implementar una funci√≥n capaz de leer l√≠nea por l√≠nea desde un descriptor de archivo (fd) hasta alcanzar el final del mismo. El objetivo es crear una funci√≥n que devuelva cada l√≠nea de texto, respetando los saltos de l√≠nea y sin perder informaci√≥n.

En este proyecto solo se permiten dos archivos .c y un archivo de cabecera .h, y no es necesario crear un Makefile, ya que se centra √∫nicamente en la l√≥gica de lectura.

El reto consiste en gestionar correctamente los buffers de lectura, almacenar la informaci√≥n le√≠da y manejar posibles errores o finales de archivo. Es un excelente ejercicio para entender la gesti√≥n de la memoria din√°mica, el control de lectura de archivos y c√≥mo manipular cadenas en C.

## Resultado Get_Next_Line

![GNL Results](https://github.com/user-attachments/assets/1ad5421b-b87a-4e28-9747-80757af13d87)

## Repositorio Get_Next_Line

https://github.com/Fren2804/Get_next_line

## Explicaci√≥n Ft_Printf

En este proyecto ten√≠amos que recrear la funci√≥n printf, pero tambi√©n se requer√≠a que la implement√°ramos como parte de una biblioteca, lo que nos devolv√≠a a la creaci√≥n de un Makefile para gestionar la compilaci√≥n y vinculaci√≥n de los archivos.

Uno de los principales desaf√≠os de este proyecto fue aprender a trabajar con argumentos vari√°dicos en C, usando las macros de la biblioteca <stdarg.h> para gestionar m√∫ltiples argumentos de manera flexible. Adem√°s, nos centramos en c√≥mo interpretar y formatear los datos de salida seg√∫n las especificaciones de formato (como %d, %s, %p, etc.), as√≠ como en imprimirlos correctamente en la salida est√°ndar.

Este proyecto no solo nos permiti√≥ afianzar conceptos previos sobre cadenas y buffers, sino tambi√©n adquirir habilidades avanzadas en el formateo y la gesti√≥n eficiente de datos. Fue una gran oportunidad para profundizar en la funcionalidad interna de una de las funciones m√°s utilizadas en C.

## Resultado Ft_Printf

![Printf Results](https://github.com/user-attachments/assets/6b7c017b-050f-4d59-adc0-a8d8bd9bd45f)

## Repositorio Ft_Printf

https://github.com/Fren2804/Ft_printf

## Explicaci√≥n Born2beroot

En este proyecto aprendemos a administrar y configurar un sistema operativo Linux desde cero, reforzando los fundamentos de la administraci√≥n de sistemas. El objetivo es entender c√≥mo instalar y configurar un servidor de manera segura, eficiente y siguiendo las buenas pr√°cticas.

Durante este proyecto, creamos una m√°quina virtual con Debian o Rocky con sus particiones y configuramos los usuarios, los grupos y los permisos adecuados para asegurar el sistema. Tambi√©n nos adentramos en la configuraci√≥n de servicios esenciales, como el SSH, y en c√≥mo aplicar pol√≠ticas de seguridad con herramientas como ufw (cortafuegos) y sudo, para conceder permisos de administraci√≥n de forma controlada.

Uno de los aspectos m√°s importantes de este proyecto es la implementaci√≥n de pol√≠ticas de contrase√±as y la creaci√≥n de un sistema que cumpla con los est√°ndares de seguridad, lo que nos da una base s√≥lida para la administraci√≥n de servidores y nos prepara para entornos de producci√≥n reales.

## Resultado Born2beroot

## Explicaci√≥n Fdf

El proyecto FDF ya pertenece al nuevo c√≠rculo, donde se nos permite y se espera que utilicemos nuestra biblioteca libft, as√≠ como las funciones get_next_line y ft_printf que implementamos en proyectos anteriores. Adem√°s, este proyecto nos introduce a una nueva herramienta: la MiniLibX, una biblioteca gr√°fica sencilla dise√±ada para renderizar gr√°ficos en 2D y 3D.

El objetivo principal de este proyecto es leer un archivo que contiene un mapa con altitudes (y opcionalmente colores) y representarlo de forma gr√°fica en un entorno 3D utilizando proyecciones isom√©tricas. Para lograrlo, debemos procesar correctamente los datos del archivo, interpretar las coordenadas y pintar los puntos en la ventana gr√°fica de MiniLibX.

Este proyecto nos ayuda a profundizar en la manipulaci√≥n de datos espaciales, las transformaciones geom√©tricas y c√≥mo renderizar elementos en una interfaz gr√°fica b√°sica. Adem√°s, pone a prueba nuestras habilidades para integrar varias bibliotecas y reforzar conceptos clave de la programaci√≥n estructurada.

## Resultado Fdf

![FDF Results](https://github.com/user-attachments/assets/5f6202fa-6891-4383-a12e-2b66a334d3f2)

## Repositorio Fdf

https://github.com/Fren2804/Fdf

## Explicaci√≥n Pipex

El objetivo principal de este proyecto es comprender el funcionamiento de los procesos y la comunicaci√≥n entre ellos, especialmente c√≥mo la shell ejecuta los comandos y gestiona los errores. Nos adentramos en el uso de los pipes y las llamadas al sistema como fork, execve, dup2 y wait, fundamentales para la programaci√≥n en C a nivel de sistema.

Durante este proyecto, debemos implementar un programa que simule el comportamiento de la shell cuando encadenamos comandos usando el operador | (pipe). Esto implica redirigir las entradas y salidas est√°ndar, gestionar correctamente la duplicaci√≥n de descriptores de archivo y asegurarnos de que los errores se manejen de forma clara y robusta.

Adem√°s, nos obliga a reforzar nuestra comprensi√≥n de la gesti√≥n de procesos en Unix/Linux y c√≥mo los programas pueden comunicarse mediante pipes para trabajar en conjunto. Es un paso clave para desarrollar herramientas m√°s complejas y aprender c√≥mo funcionan los procesos en segundo plano y la ejecuci√≥n de comandos en sistemas Unix.

## Resultado Pipex

![Pipex Results](https://github.com/user-attachments/assets/967b3616-dace-4b41-912f-2f36b2a709bc)

## Repositorio Pipex

https://github.com/Fren2804/Pipex

## Explicaci√≥n Push_Swap

Este proyecto tiene como objetivo desarrollar un algoritmo eficiente para ordenar una pila de n√∫meros utilizando un conjunto limitado de operaciones, simulando el comportamiento de un sistema de ordenaci√≥n espec√≠fico.

En Push_Swap trabajamos con dos pilas (A y B) y disponemos de un conjunto de instrucciones b√°sicas (sa, sb, pa, pb, ra, rb, rra, rrb, rr, rrr) que nos permiten realizar operaciones de intercambio, rotaci√≥n y transferencia entre las pilas. La clave del proyecto es encontrar el algoritmo m√°s eficiente posible, minimizando la cantidad de movimientos necesarios para ordenar completamente la pila A.

Este proyecto nos obliga a pensar de manera l√≥gica y estrat√©gica, aplicando conceptos de algoritmos de ordenaci√≥n y optimizaci√≥n. Adem√°s, refuerza nuestras habilidades en el manejo de estructuras de datos (pilas y listas enlazadas) y nos ense√±a la importancia de la eficiencia en la programaci√≥n.

## Resultado Push_Swap

![Push Swap Results](https://github.com/user-attachments/assets/732e2423-e6b7-4930-be7f-2d1071cca999)


## Repositorio Push_Swap

https://github.com/Fren2804/Push_Swap

## Explicaci√≥n Exam02

En este primer examen, nos enfrentamos a 4 ejercicios aleatorios de distintos niveles de dificultad, ordenados de menor a mayor. Cada uno de estos ejercicios pone a prueba conceptos clave de C y nuestra capacidad para escribir c√≥digo eficiente y correcto bajo presi√≥n.

   Mis ejercicios fueron:

‚ö´ Ejercicio 1 - Rotone

En este ejercicio, se nos pide rotar cada car√°cter al siguiente en el alfabeto, de modo que 'a' se convierte en 'b' y 'Z' en 'A'.

‚ö´ Ejercicio 2 - Reverse bits

Aqu√≠ se trata de invertir los 8 bits de un n√∫mero. Por ejemplo, el valor 0010 0110 debe transformarse en 0110 0010.

‚ö´ Ejercicio 3 - Atoi_base

Este fue el m√°s desafiante para m√≠, ya que al principio no tuve en cuenta que la base pod√≠a contener letras may√∫sculas y min√∫sculas simult√°neamente (por ejemplo, 1aA es v√°lido). Tuve que convertir una cadena en un n√∫mero entero usando cualquier base que pasaran, lo que implica manejar la validaci√≥n y conversi√≥n de caracteres de forma cuidadosa.

‚ö´ Ejercicio 4 - Itoa

Finalmente, el itoa consiste en convertir un n√∫mero entero en una cadena de caracteres, respetando los signos y teniendo en cuenta el valor m√≠nimo de los enteros (caso especial de INT_MIN en C).

## Resultado Exam02

![Exam02 Results](https://github.com/user-attachments/assets/b3579911-ac15-40bb-a538-f8d93efe81d5)

