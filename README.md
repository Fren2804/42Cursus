# üîßüß± In Progress üß±üîß
# üè¢42 Cursus - Campus 42 Madrid üá™üá∏

Bienvenido a mi repositorio del **Cursus 42**, donde ir√© subiendo todos mis proyectos completados y corregidos. Aqu√≠ encontrar√°s implementaciones en C, estructuras de datos, algoritmos y otros ejercicios desarrollados en el marco del programa de formaci√≥n de **42 Madrid**. Dentro de cada repositorio habr√° mas informaci√≥n en detalle de cada proyecto.

---

## üìö √çndice de Proyectos

### üî® Proyectos Base

| Proyecto | Explicaci√≥n | üìù Descripci√≥n |
|----------|-------------|----------------|
| üß± [Libft](https://github.com/Fren2804/Libft) | [Explicaci√≥n](#explicaci√≥n-libft) | Implementaci√≥n desde cero de funciones est√°ndar de C. |
| üìÑ [Get Next Line](https://github.com/Fren2804/Get_Next_Line) | [Explicaci√≥n](#explicaci√≥n-get_next_line) | Lectura l√≠nea por l√≠nea desde un descriptor de archivo. |
| üñ®Ô∏è [Ft_Printf](https://github.com/Fren2804/Ft_Printf) | [Explicaci√≥n](#explicaci√≥n-ft_printf) | Reimplementaci√≥n de `printf` con flags, formatos y tipos. |
| üßë‚Äçüíª [Born2beroot](#explicaci√≥n-born2beroot) | [Explicaci√≥n](#explicaci√≥n-born2beroot) | Configuraci√≥n de servidores y administraci√≥n en Linux. |

### üß† Proyectos Intermedios

| Proyecto | Explicaci√≥n | üìù Descripci√≥n |
|----------|-------------|----------------|
| üó∫Ô∏è [FDF](https://github.com/Fren2804/FDF) | [Explicaci√≥n](#explicaci√≥n-fdf) | Visualizaci√≥n 3D de mapas en wireframe usando MLX. |
| üîó [Pipex](https://github.com/Fren2804/Pipex) | [Explicaci√≥n](#explicaci√≥n-pipex) | Manejo de tuber√≠as UNIX entre procesos. |
| üîÑ [Push Swap](https://github.com/Fren2804/Push_Swap) | [Explicaci√≥n](#explicaci√≥n-push_swap) | Algoritmo para ordenar con pila y operaciones limitadas. |
| üêö [Minishell](https://github.com/Fren2804/Minishell) | [Explicaci√≥n](#explicaci√≥n-minishell) | Shell personalizada que ejecuta comandos UNIX. |
| üßä [Cub3D](https://github.com/Fren2804/cub3D) | [Explicaci√≥n](#explicaci√≥n-cub3d) | Motor 3D estilo Wolfenstein con raycasting. |
| üåê [NetPractice](#explicaci√≥n-netpractice) | [Explicaci√≥n](#explicaci√≥n-netpractice) | Simulaciones de redes y resoluci√≥n de topolog√≠as IP. |
| üçù [Philosophers](https://github.com/Fren2804/Philosophers) | [Explicaci√≥n](#explicaci√≥n-philosophers) | Resoluci√≥n del problema de los fil√≥sofos con hilos. |

### üß† Ex√°menes

| Proyecto | Explicaci√≥n | üìù Descripci√≥n |
|----------|-------------|----------------|
| üß† [Exam02](#explicaci√≥n-exam02) | [Explicaci√≥n](#explicaci√≥n-exam02) | Pruebas de l√≥gica, memoria y manejo de archivos en C. |
| üß† [Exam03](#explicaci√≥n-exam03) | [Explicaci√≥n](#explicaci√≥n-exam03) | Evaluaci√≥n avanzada de algoritmia y punteros. |
| üß† [Exam04](#explicaci√≥n-exam04) | [Explicaci√≥n](#explicaci√≥n-exam04) | Examen con retos de programaci√≥n de nivel intermedio. |
| üß† [Exam05](#explicaci√≥n-exam04) | [Explicaci√≥n](#explicaci√≥n-exam05) | Evaluaci√≥n pr√°ctica con retos de sistema. |
| üß† [Exam06](#explicaci√≥n-exam04) | [Explicaci√≥n](#explicaci√≥n-exam06) | Nivel superior con problemas complejos de dise√±o. |

### üîµ M√≥dulos C++

| Proyecto | Explicaci√≥n | üìù Descripci√≥n |
|----------|-------------|----------------|
| üîµ [CPP Module 0‚Äì4](https://github.com/Fren2804/CPP-Module-0-4) | [Explicaci√≥n](#explicaci√≥n-cpp-module-0-4) | Fundamentos de C++, clases, operadores y memoria. |
| üü£ [CPP Module 5‚Äì9](https://github.com/Fren2804/CPP-Module-5-9) | [Explicaci√≥n](#explicaci√≥n-cpp-module-5-9) | C++ avanzado: herencia, templates, containers STL. |

### üöÄ Proyectos Finales

| Proyecto | Explicaci√≥n | üìù Descripci√≥n |
|----------|-------------|----------------|
| üèóÔ∏è [Inception](https://github.com/Fren2804/Inception) | [Explicaci√≥n](#explicaci√≥n-inception) | Infraestructura de contenedores con Docker y servicios. |
| üí¨ [IRC](https://github.com/Fren2804/Irc) | [Explicaci√≥n](#explicaci√≥n-irc) | Servidor IRC funcional bajo el protocolo RFC1459. |
| üåå [Transcendence](https://github.com/Fren2804/Transcendence) | [Explicaci√≥n](#explicaci√≥n-transcendence) | Proyecto web full-stack con NestJS, PostgreSQL y m√°s. |


# Explicaci√≥n

## Explicaci√≥n Libft

Este es el primer proyecto del campus 42, en el que se nos introducen ciertas pautas fundamentales y se nos pide replicar muchas de las funciones b√°sicas de la biblioteca est√°ndar de C. El objetivo principal es que comprendamos en profundidad c√≥mo funcionan estas funciones, su prop√≥sito y c√≥mo implementarlas correctamente, ya que formar√°n la base para los pr√≥ximos proyectos.

Durante este proyecto, aprendemos a crear un Makefile que automatiza la compilaci√≥n y generaci√≥n de la biblioteca. Tambi√©n nos enfocamos en vincular todos los archivos .c mediante un archivo de cabecera .h, lo que nos permite generar una biblioteca completamente funcional.

La experiencia adquirida en este proyecto nos ayuda a dominar el manejo de memoria din√°mica, las cadenas de caracteres y otras operaciones fundamentales en C, sentando las bases para convertirnos en desarrolladores m√°s s√≥lidos y organizados.

## Resultado Libft

![Libft Results](https://github.com/user-attachments/assets/11105315-a2a0-4cc2-8c29-3cc0c523f2e4)

## Repositorio Libft

https://github.com/Fren2804/Libft

## Explicaci√≥n Get_Next_Line

Este fue mi segundo proyecto, en el que se nos pide implementar una funci√≥n capaz de leer l√≠nea por l√≠nea desde un descriptor de archivo (fd) hasta alcanzar el final del mismo. El objetivo es crear una funci√≥n que devuelva cada l√≠nea de texto, respetando los saltos de l√≠nea y sin perder informaci√≥n.

En este proyecto solo se permiten dos archivos .c y un archivo de cabecera .h, y no es necesario crear un Makefile, ya que se centra √∫nicamente en la l√≥gica de lectura.

El reto consiste en gestionar correctamente los buffers de lectura, almacenar la informaci√≥n le√≠da y manejar posibles errores o finales de archivo. Es un excelente ejercicio para entender la gesti√≥n de la memoria din√°mica, el control de lectura de archivos y c√≥mo manipular cadenas en C.

## Resultado Get_Next_Line

![GNL Results](https://github.com/user-attachments/assets/1ad5421b-b87a-4e28-9747-80757af13d87)

## Repositorio Get_Next_Line

https://github.com/Fren2804/Get_next_line

## Explicaci√≥n Ft_Printf

En este proyecto ten√≠amos que recrear la funci√≥n printf, pero tambi√©n se requer√≠a que la implement√°ramos como parte de una biblioteca, lo que nos devolv√≠a a la creaci√≥n de un Makefile para gestionar la compilaci√≥n y vinculaci√≥n de los archivos.

Uno de los principales desaf√≠os de este proyecto fue aprender a trabajar con argumentos vari√°dicos en C, usando las macros de la biblioteca <stdarg.h> para gestionar m√∫ltiples argumentos de manera flexible. Adem√°s, nos centramos en c√≥mo interpretar y formatear los datos de salida seg√∫n las especificaciones de formato (como %d, %s, %p, etc.), as√≠ como en imprimirlos correctamente en la salida est√°ndar.

Este proyecto no solo nos permiti√≥ afianzar conceptos previos sobre cadenas y buffers, sino tambi√©n adquirir habilidades avanzadas en el formateo y la gesti√≥n eficiente de datos. Fue una gran oportunidad para profundizar en la funcionalidad interna de una de las funciones m√°s utilizadas en C.

## Resultado Ft_Printf

![Printf Results](https://github.com/user-attachments/assets/6b7c017b-050f-4d59-adc0-a8d8bd9bd45f)

## Repositorio Ft_Printf

https://github.com/Fren2804/Ft_printf

## Explicaci√≥n Born2beroot

En este proyecto aprendemos a administrar y configurar un sistema operativo Linux desde cero, reforzando los fundamentos de la administraci√≥n de sistemas. El objetivo es entender c√≥mo instalar y configurar un servidor de manera segura, eficiente y siguiendo las buenas pr√°cticas.

Durante este proyecto, creamos una m√°quina virtual con Debian o Rocky con sus particiones y configuramos los usuarios, los grupos y los permisos adecuados para asegurar el sistema. Tambi√©n nos adentramos en la configuraci√≥n de servicios esenciales, como el SSH, y en c√≥mo aplicar pol√≠ticas de seguridad con herramientas como ufw (cortafuegos) y sudo, para conceder permisos de administraci√≥n de forma controlada.

Uno de los aspectos m√°s importantes de este proyecto es la implementaci√≥n de pol√≠ticas de contrase√±as y la creaci√≥n de un sistema que cumpla con los est√°ndares de seguridad, lo que nos da una base s√≥lida para la administraci√≥n de servidores y nos prepara para entornos de producci√≥n reales.

## Resultado Born2beroot

![Born2beroot Results](https://github.com/user-attachments/assets/01201ea8-6903-4b34-80fe-6bd01c795fe2)

## Explicaci√≥n Fdf

El proyecto FDF ya pertenece al nuevo c√≠rculo, donde se nos permite y se espera que utilicemos nuestra biblioteca libft, as√≠ como las funciones get_next_line y ft_printf que implementamos en proyectos anteriores. Adem√°s, este proyecto nos introduce a una nueva herramienta: la MiniLibX, una biblioteca gr√°fica sencilla dise√±ada para renderizar gr√°ficos en 2D y 3D.

El objetivo principal de este proyecto es leer un archivo que contiene un mapa con altitudes (y opcionalmente colores) y representarlo de forma gr√°fica en un entorno 3D utilizando proyecciones isom√©tricas. Para lograrlo, debemos procesar correctamente los datos del archivo, interpretar las coordenadas y pintar los puntos en la ventana gr√°fica de MiniLibX.

Este proyecto nos ayuda a profundizar en la manipulaci√≥n de datos espaciales, las transformaciones geom√©tricas y c√≥mo renderizar elementos en una interfaz gr√°fica b√°sica. Adem√°s, pone a prueba nuestras habilidades para integrar varias bibliotecas y reforzar conceptos clave de la programaci√≥n estructurada.

## Resultado Fdf

![FDF Results](https://github.com/user-attachments/assets/5f6202fa-6891-4383-a12e-2b66a334d3f2)

## Repositorio Fdf

https://github.com/Fren2804/Fdf

## Explicaci√≥n Pipex

El objetivo principal de este proyecto es comprender el funcionamiento de los procesos y la comunicaci√≥n entre ellos, especialmente c√≥mo la shell ejecuta los comandos y gestiona los errores. Nos adentramos en el uso de los pipes y las llamadas al sistema como fork, execve, dup2 y wait, fundamentales para la programaci√≥n en C a nivel de sistema.

Durante este proyecto, debemos implementar un programa que simule el comportamiento de la shell cuando encadenamos comandos usando el operador | (pipe). Esto implica redirigir las entradas y salidas est√°ndar, gestionar correctamente la duplicaci√≥n de descriptores de archivo y asegurarnos de que los errores se manejen de forma clara y robusta.

Adem√°s, nos obliga a reforzar nuestra comprensi√≥n de la gesti√≥n de procesos en Unix/Linux y c√≥mo los programas pueden comunicarse mediante pipes para trabajar en conjunto. Es un paso clave para desarrollar herramientas m√°s complejas y aprender c√≥mo funcionan los procesos en segundo plano y la ejecuci√≥n de comandos en sistemas Unix.

## Resultado Pipex

![Pipex Results](https://github.com/user-attachments/assets/967b3616-dace-4b41-912f-2f36b2a709bc)

## Repositorio Pipex

https://github.com/Fren2804/Pipex

## Explicaci√≥n Push_Swap

Este proyecto tiene como objetivo desarrollar un algoritmo eficiente para ordenar una pila de n√∫meros utilizando un conjunto limitado de operaciones, simulando el comportamiento de un sistema de ordenaci√≥n espec√≠fico.

En Push_Swap trabajamos con dos pilas (A y B) y disponemos de un conjunto de instrucciones b√°sicas (sa, sb, pa, pb, ra, rb, rra, rrb, rr, rrr) que nos permiten realizar operaciones de intercambio, rotaci√≥n y transferencia entre las pilas. La clave del proyecto es encontrar el algoritmo m√°s eficiente posible, minimizando la cantidad de movimientos necesarios para ordenar completamente la pila A.

Este proyecto nos obliga a pensar de manera l√≥gica y estrat√©gica, aplicando conceptos de algoritmos de ordenaci√≥n y optimizaci√≥n. Adem√°s, refuerza nuestras habilidades en el manejo de estructuras de datos (pilas y listas enlazadas) y nos ense√±a la importancia de la eficiencia en la programaci√≥n.

## Resultado Push_Swap

![Push Swap Results](https://github.com/user-attachments/assets/732e2423-e6b7-4930-be7f-2d1071cca999)


## Repositorio Push_Swap

https://github.com/Fren2804/Push_Swap

## Explicaci√≥n Exam02

En este primer examen, nos enfrentamos a 4 ejercicios aleatorios de distintos niveles de dificultad, ordenados de menor a mayor. Cada uno de estos ejercicios pone a prueba conceptos clave de C y nuestra capacidad para escribir c√≥digo eficiente y correcto bajo presi√≥n.

   Mis ejercicios fueron:

‚ö´ Ejercicio 1 - Rotone

En este ejercicio, se nos pide rotar cada car√°cter al siguiente en el alfabeto, de modo que 'a' se convierte en 'b' y 'Z' en 'A'.

‚ö´ Ejercicio 2 - Reverse bits

Aqu√≠ se trata de invertir los 8 bits de un n√∫mero. Por ejemplo, el valor 0010 0110 debe transformarse en 0110 0010.

‚ö´ Ejercicio 3 - Atoi_base

Este fue el m√°s desafiante para m√≠, ya que al principio no tuve en cuenta que la base pod√≠a contener letras may√∫sculas y min√∫sculas simult√°neamente (por ejemplo, 1aA es v√°lido). Tuve que convertir una cadena en un n√∫mero entero usando cualquier base que pasaran, lo que implica manejar la validaci√≥n y conversi√≥n de caracteres de forma cuidadosa.

‚ö´ Ejercicio 4 - Itoa

Finalmente, el itoa consiste en convertir un n√∫mero entero en una cadena de caracteres, respetando los signos y teniendo en cuenta el valor m√≠nimo de los enteros (caso especial de INT_MIN en C).

## Resultado Exam02

![Exam02 Results](https://github.com/user-attachments/assets/b3579911-ac15-40bb-a538-f8d93efe81d5)

## Explicaci√≥n Philosophers

El objetivo principal de este proyecto es comprender el funcionamiento de los hilos (threads), la sincronizaci√≥n entre ellos y los problemas cl√°sicos de concurrencia, como el de los fil√≥sofos comensales.

Durante este proyecto, debemos implementar una simulaci√≥n del problema de los fil√≥sofos comensales, en el que varios fil√≥sofos se sientan alrededor de una mesa con un tenedor por cada fil√≥sofo. Y cada fil√≥sofo necesita dos tenedores para poder comer, lo que nos obliga a gestionar cuidadosamente el acceso concurrente a los recursos compartidos usando mutexes.

El proyecto se centra en aprender a evitar condiciones de carrera (race conditions), interbloqueos (deadlocks) y otros errores comunes en la programaci√≥n concurrente. Esto se logra utilizando herramientas como pthread_create, pthread_mutex_lock, pthread_mutex_unlock, y otras funciones de la biblioteca pthread.

## Resultado Philosophers

<!-- ![Pipex Results](https://github.com/user-attachments/assets/967b3616-dace-4b41-912f-2f36b2a709bc) -->

## Repositorio Philosophers

https://github.com/Fren2804/Philosophers

## Explicaci√≥n Minishell

El objetivo principal de este proyecto es implementar una versi√≥n simplificada de una shell de Unix (siguiendo el funcionamiento de como lo hace bash), permiti√©ndonos comprender c√≥mo funciona internamente una shell real.

Durante este proyecto, debemos gestionar la lectura de comandos del usuario, su interpretaci√≥n (parsing), la ejecuci√≥n de comandos internos, los built-in (como cd, echo, export, etc.) y externos, el manejo de variables de entorno, la redirecci√≥n de entrada/salida (<, >, >>), los heredoc (<<), los pipes (|), y la gesti√≥n de se√±ales (como Ctrl+C, Ctrl+\ y Ctrl+D).

Esto implica un uso intensivo de llamadas al sistema como fork, execve, pipe, dup2, waitpid, as√≠ como estructuras de datos para organizar y ejecutar los comandos de forma correcta y robusta.

Minishell es un proyecto clave para profundizar en la programaci√≥n de bajo nivel en C, entender c√≥mo los procesos y la comunicaci√≥n entre ellos funcionan, y reforzar la l√≥gica detr√°s de la construcci√≥n de herramientas similares a las que usamos diariamente en la terminal.

## Resultado Minishell

<!-- ![Pipex Results](https://github.com/user-attachments/assets/967b3616-dace-4b41-912f-2f36b2a709bc) -->

## Repositorio Minishell

https://github.com/Fren2804/Minishell

