# ğŸ”§ğŸ§± In Progress ğŸ§±ğŸ”§
# ğŸ¢42 Cursus - Campus 42 Madrid ğŸ‡ªğŸ‡¸

Bienvenido a mi repositorio del **Cursus 42**. AquÃ­ encontrarÃ¡s implementaciones en C, estructuras de datos, algoritmos y otros ejercicios desarrollados en el marco del programa de formaciÃ³n de **42 Madrid**. Dentro de cada repositorio habrÃ¡ mas informaciÃ³n en detalle de cada proyecto.

---

## ğŸ“š Ãndice de Proyectos

### ğŸ”¨ Proyectos Base

| Proyecto | ExplicaciÃ³n | ğŸ“ DescripciÃ³n |
|----------|-------------|----------------|
| ğŸ§± [Libft](https://github.com/Fren2804/Libft) | [ExplicaciÃ³n](#explicaciÃ³n-libft) | ImplementaciÃ³n desde cero de funciones estÃ¡ndar de C. |
| ğŸ“„ [Get Next Line](https://github.com/Fren2804/Get_Next_Line) | [ExplicaciÃ³n](#explicaciÃ³n-get_next_line) | Lectura lÃ­nea por lÃ­nea desde un descriptor de archivo. |
| ğŸ–¨ï¸ [Ft_Printf](https://github.com/Fren2804/Ft_Printf) | [ExplicaciÃ³n](#explicaciÃ³n-ft_printf) | ReimplementaciÃ³n de `printf` con flags, formatos y tipos. |
| ğŸ§‘â€ğŸ’» [Born2beroot](#explicaciÃ³n-born2beroot) | [ExplicaciÃ³n](#explicaciÃ³n-born2beroot) | ConfiguraciÃ³n de servidores y administraciÃ³n en Linux. |

### ğŸ§  Proyectos Intermedios

| Proyecto | ExplicaciÃ³n | ğŸ“ DescripciÃ³n |
|----------|-------------|----------------|
| ğŸ—ºï¸ [FDF](https://github.com/Fren2804/FDF) | [ExplicaciÃ³n](#explicaciÃ³n-fdf) | VisualizaciÃ³n 3D de mapas en wireframe usando MLX. |
| ğŸ”— [Pipex](https://github.com/Fren2804/Pipex) | [ExplicaciÃ³n](#explicaciÃ³n-pipex) | Manejo de tuberÃ­as UNIX entre procesos. |
| ğŸ”„ [Push Swap](https://github.com/Fren2804/Push_Swap) | [ExplicaciÃ³n](#explicaciÃ³n-push_swap) | Algoritmo para ordenar con pila y operaciones limitadas. |
| ğŸš [Minishell](https://github.com/Fren2804/Minishell) | [ExplicaciÃ³n](#explicaciÃ³n-minishell) | Shell personalizada que ejecuta comandos UNIX. |
| ğŸ§Š [Cub3D](https://github.com/Fren2804/cub3D) | [ExplicaciÃ³n](#explicaciÃ³n-cub3d) | Motor 3D estilo Wolfenstein con raycasting. |
| ğŸŒ [NetPractice](#explicaciÃ³n-netpractice) | [ExplicaciÃ³n](#explicaciÃ³n-netpractice) | Simulaciones de redes y resoluciÃ³n de topologÃ­as IP. |
| ğŸ [Philosophers](https://github.com/Fren2804/Philosophers) | [ExplicaciÃ³n](#explicaciÃ³n-philosophers) | ResoluciÃ³n del problema de los filÃ³sofos con hilos. |

### ğŸ§  ExÃ¡menes

| Proyecto | ExplicaciÃ³n | ğŸ“ DescripciÃ³n |
|----------|-------------|----------------|
| ğŸ§  [Exam02](#explicaciÃ³n-exam02) | [ExplicaciÃ³n](#explicaciÃ³n-exam02) | Pruebas de lÃ³gica, memoria y manejo de archivos en C. |
| ğŸ§  [Exam03](#explicaciÃ³n-exam03) | [ExplicaciÃ³n](#explicaciÃ³n-exam03) | EvaluaciÃ³n avanzada de algoritmia y punteros. |
| ğŸ§  [Exam04](#explicaciÃ³n-exam04) | [ExplicaciÃ³n](#explicaciÃ³n-exam04) | Examen con retos de programaciÃ³n de nivel intermedio. |
| ğŸ§  [Exam05](#explicaciÃ³n-exam04) | [ExplicaciÃ³n](#explicaciÃ³n-exam05) | EvaluaciÃ³n prÃ¡ctica con retos de sistema. |
| ğŸ§  [Exam06](#explicaciÃ³n-exam04) | [ExplicaciÃ³n](#explicaciÃ³n-exam06) | Nivel superior con problemas complejos de diseÃ±o. |

### ğŸ”µ MÃ³dulos C++

| Proyecto | ExplicaciÃ³n | ğŸ“ DescripciÃ³n |
|----------|-------------|----------------|
| ğŸ”µ [CPP Module 0â€“4](https://github.com/Fren2804/CPP-Module-0-4) | [ExplicaciÃ³n](#explicaciÃ³n-cpp-module-0-4) | Fundamentos de C++, clases, operadores y memoria. |
| ğŸŸ£ [CPP Module 5â€“9](https://github.com/Fren2804/CPP-Module-5-9) | [ExplicaciÃ³n](#explicaciÃ³n-cpp-module-5-9) | C++ avanzado: herencia, templates, containers STL. |

### ğŸš€ Proyectos Finales

| Proyecto | ExplicaciÃ³n | ğŸ“ DescripciÃ³n |
|----------|-------------|----------------|
| ğŸ—ï¸ [Inception](https://github.com/Fren2804/Inception) | [ExplicaciÃ³n](#explicaciÃ³n-inception) | Infraestructura de contenedores con Docker y servicios. |
| ğŸ’¬ [IRC](https://github.com/Fren2804/Irc) | [ExplicaciÃ³n](#explicaciÃ³n-irc) | Servidor IRC funcional bajo el protocolo RFC1459. |
| ğŸŒŒ [Transcendence](https://github.com/Fren2804/Transcendence) | [ExplicaciÃ³n](#explicaciÃ³n-transcendence) | Proyecto web full-stack con NestJS, PostgreSQL y mÃ¡s. |


## ğŸ§± ExplicaciÃ³n Libft

**Libft** es el primer proyecto del campus 42. Se trata de una reimplementaciÃ³n de muchas funciones estÃ¡ndar de la biblioteca de C.  
El objetivo principal es comprender en profundidad su funcionamiento, su utilidad y cÃ³mo implementarlas correctamente desde cero, ya que serÃ¡n la base de muchos proyectos posteriores.

---

### ğŸ§  Â¿QuÃ© se aprende?

- Manejo de memoria dinÃ¡mica en C.
- ManipulaciÃ³n de cadenas y arrays.
- OrganizaciÃ³n del cÃ³digo en archivos `.c` y `.h`.
- CreaciÃ³n de un Makefile para compilar una librerÃ­a estÃ¡tica.
- Normas de estilo y buenas prÃ¡cticas de programaciÃ³n.

Este proyecto nos enseÃ±a a **pensar como desarrolladores de bajo nivel**, prestando atenciÃ³n al detalle, la optimizaciÃ³n y el diseÃ±o limpio del cÃ³digo.

---

### âœ… Resultado

![Libft Results](https://github.com/user-attachments/assets/11105315-a2a0-4cc2-8c29-3cc0c523f2e4)

---

### ğŸ“ Repositorio

ğŸ”— [https://github.com/Fren2804/Libft](https://github.com/Fren2804/Libft)

---


## ğŸ“„ ExplicaciÃ³n Get_Next_Line

**Get Next Line** es el segundo proyecto del campus 42.  
Consiste en implementar una funciÃ³n capaz de leer un archivo lÃ­nea por lÃ­nea a travÃ©s de un descriptor de archivo (`fd`), devolviendo cada lÃ­nea sin perder los saltos de lÃ­nea.

---

### ğŸ§  Â¿QuÃ© se aprende?

- Lectura fragmentada desde un descriptor de archivo.
- GestiÃ³n de buffers y almacenamiento temporal.
- Uso de memoria dinÃ¡mica para construir cadenas de texto.
- ManipulaciÃ³n eficiente de punteros y strings en C.
- Manejo de condiciones de fin de archivo y errores.

En este proyecto solo se permiten **dos archivos `.c` y un `.h`**, y no se exige Makefile. Se trata de un desafÃ­o muy Ãºtil para entender cÃ³mo funciona la lectura por partes y cÃ³mo construir una lÃ³gica robusta de acumulaciÃ³n y entrega de datos.

---

### âœ… Resultado

![GNL Results](https://github.com/user-attachments/assets/1ad5421b-b87a-4e28-9747-80757af13d87)

---

### ğŸ“ Repositorio

ğŸ”— [https://github.com/Fren2804/Get_next_line](https://github.com/Fren2804/Get_next_line)

---


## ğŸ–¨ï¸ ExplicaciÃ³n Ft_Printf

**Ft_Printf** es el tercer proyecto del campus 42.  
En Ã©l, se nos pide **recrear la funciÃ³n `printf`**, pero implementÃ¡ndola como parte de una **librerÃ­a**, lo que nos lleva nuevamente a crear un **Makefile** para gestionar la compilaciÃ³n y vinculaciÃ³n de los archivos.

---

### ğŸ§  Â¿QuÃ© se aprende?

- Uso de **argumentos variÃ¡dicos** en C mediante `<stdarg.h>`.
- InterpretaciÃ³n y formateo de los distintos **especificadores de formato** (`%d`, `%s`, `%p`, `%x`, etc.).
- ConversiÃ³n de datos a texto y su impresiÃ³n en la salida estÃ¡ndar.
- Manejo de buffers, strings y funciones reutilizables.
- OrganizaciÃ³n modular del cÃ³digo y compilaciÃ³n de librerÃ­as.

Este proyecto refuerza la comprensiÃ³n de las **funciones de salida y del formateo de datos**, permitiÃ©ndonos entender cÃ³mo trabaja internamente una de las funciones mÃ¡s emblemÃ¡ticas del lenguaje C.

---

### âœ… Resultado

![Printf Results](https://github.com/user-attachments/assets/6b7c017b-050f-4d59-adc0-a8d8bd9bd45f)

---

### ğŸ“ Repositorio

ğŸ”— [https://github.com/Fren2804/Ft_printf](https://github.com/Fren2804/Ft_printf)

---


## ğŸ§‘â€ğŸ’» ExplicaciÃ³n Born2beroot

**Born2beroot** es un proyecto orientado a introducirnos en la **administraciÃ³n de sistemas Linux** desde cero.  
El objetivo es aprender a instalar, configurar y asegurar un servidor siguiendo buenas prÃ¡cticas del mundo real.

---

### ğŸ§  Â¿QuÃ© se aprende?

- InstalaciÃ³n de una **mÃ¡quina virtual** con Debian o Rocky Linux.
- CreaciÃ³n y particionado manual del disco.
- ConfiguraciÃ³n de usuarios, grupos y permisos.
- ActivaciÃ³n y securizaciÃ³n del acceso **SSH**.
- AplicaciÃ³n de **polÃ­ticas de contraseÃ±as** seguras.
- ConfiguraciÃ³n de herramientas clave como `sudo` y `ufw` (cortafuegos).

El proyecto hace hincapiÃ© en la **seguridad del sistema**, enseÃ±ando cÃ³mo protegerlo desde su instalaciÃ³n, y cÃ³mo establecer controles de acceso robustos para usuarios y administradores.

---

### âœ… Resultado

![Born2beroot Results](https://github.com/user-attachments/assets/01201ea8-6903-4b34-80fe-6bd01c795fe2)

## ExplicaciÃ³n Fdf

El proyecto FDF ya pertenece al nuevo cÃ­rculo, donde se nos permite y se espera que utilicemos nuestra biblioteca libft, asÃ­ como las funciones get_next_line y ft_printf que implementamos en proyectos anteriores. AdemÃ¡s, este proyecto nos introduce a una nueva herramienta: la MiniLibX, una biblioteca grÃ¡fica sencilla diseÃ±ada para renderizar grÃ¡ficos en 2D y 3D.

El objetivo principal de este proyecto es leer un archivo que contiene un mapa con altitudes (y opcionalmente colores) y representarlo de forma grÃ¡fica en un entorno 3D utilizando proyecciones isomÃ©tricas. Para lograrlo, debemos procesar correctamente los datos del archivo, interpretar las coordenadas y pintar los puntos en la ventana grÃ¡fica de MiniLibX.

Este proyecto nos ayuda a profundizar en la manipulaciÃ³n de datos espaciales, las transformaciones geomÃ©tricas y cÃ³mo renderizar elementos en una interfaz grÃ¡fica bÃ¡sica. AdemÃ¡s, pone a prueba nuestras habilidades para integrar varias bibliotecas y reforzar conceptos clave de la programaciÃ³n estructurada.

## Resultado Fdf

![FDF Results](https://github.com/user-attachments/assets/5f6202fa-6891-4383-a12e-2b66a334d3f2)

## Repositorio Fdf

https://github.com/Fren2804/Fdf

## ExplicaciÃ³n Pipex

El objetivo principal de este proyecto es comprender el funcionamiento de los procesos y la comunicaciÃ³n entre ellos, especialmente cÃ³mo la shell ejecuta los comandos y gestiona los errores. Nos adentramos en el uso de los pipes y las llamadas al sistema como fork, execve, dup2 y wait, fundamentales para la programaciÃ³n en C a nivel de sistema.

Durante este proyecto, debemos implementar un programa que simule el comportamiento de la shell cuando encadenamos comandos usando el operador | (pipe). Esto implica redirigir las entradas y salidas estÃ¡ndar, gestionar correctamente la duplicaciÃ³n de descriptores de archivo y asegurarnos de que los errores se manejen de forma clara y robusta.

AdemÃ¡s, nos obliga a reforzar nuestra comprensiÃ³n de la gestiÃ³n de procesos en Unix/Linux y cÃ³mo los programas pueden comunicarse mediante pipes para trabajar en conjunto. Es un paso clave para desarrollar herramientas mÃ¡s complejas y aprender cÃ³mo funcionan los procesos en segundo plano y la ejecuciÃ³n de comandos en sistemas Unix.

## Resultado Pipex

![Pipex Results](https://github.com/user-attachments/assets/967b3616-dace-4b41-912f-2f36b2a709bc)

## Repositorio Pipex

https://github.com/Fren2804/Pipex

## ExplicaciÃ³n Push_Swap

Este proyecto tiene como objetivo desarrollar un algoritmo eficiente para ordenar una pila de nÃºmeros utilizando un conjunto limitado de operaciones, simulando el comportamiento de un sistema de ordenaciÃ³n especÃ­fico.

En Push_Swap trabajamos con dos pilas (A y B) y disponemos de un conjunto de instrucciones bÃ¡sicas (sa, sb, pa, pb, ra, rb, rra, rrb, rr, rrr) que nos permiten realizar operaciones de intercambio, rotaciÃ³n y transferencia entre las pilas. La clave del proyecto es encontrar el algoritmo mÃ¡s eficiente posible, minimizando la cantidad de movimientos necesarios para ordenar completamente la pila A.

Este proyecto nos obliga a pensar de manera lÃ³gica y estratÃ©gica, aplicando conceptos de algoritmos de ordenaciÃ³n y optimizaciÃ³n. AdemÃ¡s, refuerza nuestras habilidades en el manejo de estructuras de datos (pilas y listas enlazadas) y nos enseÃ±a la importancia de la eficiencia en la programaciÃ³n.

## Resultado Push_Swap

![Push Swap Results](https://github.com/user-attachments/assets/732e2423-e6b7-4930-be7f-2d1071cca999)


## Repositorio Push_Swap

https://github.com/Fren2804/Push_Swap

## ExplicaciÃ³n Exam02

En este primer examen, nos enfrentamos a 4 ejercicios aleatorios de distintos niveles de dificultad, ordenados de menor a mayor. Cada uno de estos ejercicios pone a prueba conceptos clave de C y nuestra capacidad para escribir cÃ³digo eficiente y correcto bajo presiÃ³n.

   Mis ejercicios fueron:

âš« Ejercicio 1 - Rotone

En este ejercicio, se nos pide rotar cada carÃ¡cter al siguiente en el alfabeto, de modo que 'a' se convierte en 'b' y 'Z' en 'A'.

âš« Ejercicio 2 - Reverse bits

AquÃ­ se trata de invertir los 8 bits de un nÃºmero. Por ejemplo, el valor 0010 0110 debe transformarse en 0110 0010.

âš« Ejercicio 3 - Atoi_base

Este fue el mÃ¡s desafiante para mÃ­, ya que al principio no tuve en cuenta que la base podÃ­a contener letras mayÃºsculas y minÃºsculas simultÃ¡neamente (por ejemplo, 1aA es vÃ¡lido). Tuve que convertir una cadena en un nÃºmero entero usando cualquier base que pasaran, lo que implica manejar la validaciÃ³n y conversiÃ³n de caracteres de forma cuidadosa.

âš« Ejercicio 4 - Itoa

Finalmente, el itoa consiste en convertir un nÃºmero entero en una cadena de caracteres, respetando los signos y teniendo en cuenta el valor mÃ­nimo de los enteros (caso especial de INT_MIN en C).

## Resultado Exam02

![Exam02 Results](https://github.com/user-attachments/assets/b3579911-ac15-40bb-a538-f8d93efe81d5)

## ExplicaciÃ³n Philosophers

El objetivo principal de este proyecto es comprender el funcionamiento de los hilos (threads), la sincronizaciÃ³n entre ellos y los problemas clÃ¡sicos de concurrencia, como el de los filÃ³sofos comensales.

Durante este proyecto, debemos implementar una simulaciÃ³n del problema de los filÃ³sofos comensales, en el que varios filÃ³sofos se sientan alrededor de una mesa con un tenedor por cada filÃ³sofo. Y cada filÃ³sofo necesita dos tenedores para poder comer, lo que nos obliga a gestionar cuidadosamente el acceso concurrente a los recursos compartidos usando mutexes.

El proyecto se centra en aprender a evitar condiciones de carrera (race conditions), interbloqueos (deadlocks) y otros errores comunes en la programaciÃ³n concurrente. Esto se logra utilizando herramientas como pthread_create, pthread_mutex_lock, pthread_mutex_unlock, y otras funciones de la biblioteca pthread.

## Resultado Philosophers

<!-- ![Pipex Results](https://github.com/user-attachments/assets/967b3616-dace-4b41-912f-2f36b2a709bc) -->

## Repositorio Philosophers

https://github.com/Fren2804/Philosophers

## ExplicaciÃ³n Minishell

El objetivo principal de este proyecto es implementar una versiÃ³n simplificada de una shell de Unix (siguiendo el funcionamiento de como lo hace bash), permitiÃ©ndonos comprender cÃ³mo funciona internamente una shell real.

Durante este proyecto, debemos gestionar la lectura de comandos del usuario, su interpretaciÃ³n (parsing), la ejecuciÃ³n de comandos internos, los built-in (como cd, echo, export, etc.) y externos, el manejo de variables de entorno, la redirecciÃ³n de entrada/salida (<, >, >>), los heredoc (<<), los pipes (|), y la gestiÃ³n de seÃ±ales (como Ctrl+C, Ctrl+\ y Ctrl+D).

Esto implica un uso intensivo de llamadas al sistema como fork, execve, pipe, dup2, waitpid, asÃ­ como estructuras de datos para organizar y ejecutar los comandos de forma correcta y robusta.

Minishell es un proyecto clave para profundizar en la programaciÃ³n de bajo nivel en C, entender cÃ³mo los procesos y la comunicaciÃ³n entre ellos funcionan, y reforzar la lÃ³gica detrÃ¡s de la construcciÃ³n de herramientas similares a las que usamos diariamente en la terminal.

## Resultado Minishell

<!-- ![Pipex Results](https://github.com/user-attachments/assets/967b3616-dace-4b41-912f-2f36b2a709bc) -->

## Repositorio Minishell

https://github.com/Fren2804/Minishell

